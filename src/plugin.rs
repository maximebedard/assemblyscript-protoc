// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `proto/plugin.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
pub struct Version {
    // message fields
    major: ::std::option::Option<i32>,
    minor: ::std::option::Option<i32>,
    patch: ::std::option::Option<i32>,
    suffix: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Version {
    fn default() -> &'a Version {
        <Version as ::protobuf::Message>::default_instance()
    }
}

impl Version {
    pub fn new() -> Version {
        ::std::default::Default::default()
    }

    // optional int32 major = 1;


    pub fn get_major(&self) -> i32 {
        self.major.unwrap_or(0)
    }
    pub fn clear_major(&mut self) {
        self.major = ::std::option::Option::None;
    }

    pub fn has_major(&self) -> bool {
        self.major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: i32) {
        self.major = ::std::option::Option::Some(v);
    }

    // optional int32 minor = 2;


    pub fn get_minor(&self) -> i32 {
        self.minor.unwrap_or(0)
    }
    pub fn clear_minor(&mut self) {
        self.minor = ::std::option::Option::None;
    }

    pub fn has_minor(&self) -> bool {
        self.minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: i32) {
        self.minor = ::std::option::Option::Some(v);
    }

    // optional int32 patch = 3;


    pub fn get_patch(&self) -> i32 {
        self.patch.unwrap_or(0)
    }
    pub fn clear_patch(&mut self) {
        self.patch = ::std::option::Option::None;
    }

    pub fn has_patch(&self) -> bool {
        self.patch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch(&mut self, v: i32) {
        self.patch = ::std::option::Option::Some(v);
    }

    // optional string suffix = 4;


    pub fn get_suffix(&self) -> &str {
        match self.suffix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_suffix(&mut self) {
        self.suffix.clear();
    }

    pub fn has_suffix(&self) -> bool {
        self.suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suffix(&mut self, v: ::std::string::String) {
        self.suffix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_suffix(&mut self) -> &mut ::std::string::String {
        if self.suffix.is_none() {
            self.suffix.set_default();
        }
        self.suffix.as_mut().unwrap()
    }

    // Take field
    pub fn take_suffix(&mut self) -> ::std::string::String {
        self.suffix.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Version {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.major = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minor = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.patch = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.suffix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.major {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minor {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.patch {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.suffix.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.major {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.minor {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.patch {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.suffix.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Version {
        Version::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "major",
                    |m: &Version| { &m.major },
                    |m: &mut Version| { &mut m.major },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "minor",
                    |m: &Version| { &m.minor },
                    |m: &mut Version| { &mut m.minor },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "patch",
                    |m: &Version| { &m.patch },
                    |m: &mut Version| { &mut m.patch },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "suffix",
                    |m: &Version| { &m.suffix },
                    |m: &mut Version| { &mut m.suffix },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Version>(
                    "Version",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Version {
        static mut instance: ::protobuf::lazy::Lazy<Version> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Version::new)
        }
    }
}

impl ::protobuf::Clear for Version {
    fn clear(&mut self) {
        self.major = ::std::option::Option::None;
        self.minor = ::std::option::Option::None;
        self.patch = ::std::option::Option::None;
        self.suffix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Version {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Version {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodeGeneratorRequest {
    // message fields
    file_to_generate: ::protobuf::RepeatedField<::std::string::String>,
    parameter: ::protobuf::SingularField<::std::string::String>,
    proto_file: ::protobuf::RepeatedField<::protobuf::descriptor::FileDescriptorProto>,
    compiler_version: ::protobuf::SingularPtrField<Version>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CodeGeneratorRequest {
    fn default() -> &'a CodeGeneratorRequest {
        <CodeGeneratorRequest as ::protobuf::Message>::default_instance()
    }
}

impl CodeGeneratorRequest {
    pub fn new() -> CodeGeneratorRequest {
        ::std::default::Default::default()
    }

    // repeated string file_to_generate = 1;


    pub fn get_file_to_generate(&self) -> &[::std::string::String] {
        &self.file_to_generate
    }
    pub fn clear_file_to_generate(&mut self) {
        self.file_to_generate.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_to_generate(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.file_to_generate = v;
    }

    // Mutable pointer to the field.
    pub fn mut_file_to_generate(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.file_to_generate
    }

    // Take field
    pub fn take_file_to_generate(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.file_to_generate, ::protobuf::RepeatedField::new())
    }

    // optional string parameter = 2;


    pub fn get_parameter(&self) -> &str {
        match self.parameter.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_parameter(&mut self) {
        self.parameter.clear();
    }

    pub fn has_parameter(&self) -> bool {
        self.parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameter(&mut self, v: ::std::string::String) {
        self.parameter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameter(&mut self) -> &mut ::std::string::String {
        if self.parameter.is_none() {
            self.parameter.set_default();
        }
        self.parameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameter(&mut self) -> ::std::string::String {
        self.parameter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .google.protobuf.FileDescriptorProto proto_file = 15;


    pub fn get_proto_file(&self) -> &[::protobuf::descriptor::FileDescriptorProto] {
        &self.proto_file
    }
    pub fn clear_proto_file(&mut self) {
        self.proto_file.clear();
    }

    // Param is passed by value, moved
    pub fn set_proto_file(&mut self, v: ::protobuf::RepeatedField<::protobuf::descriptor::FileDescriptorProto>) {
        self.proto_file = v;
    }

    // Mutable pointer to the field.
    pub fn mut_proto_file(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::descriptor::FileDescriptorProto> {
        &mut self.proto_file
    }

    // Take field
    pub fn take_proto_file(&mut self) -> ::protobuf::RepeatedField<::protobuf::descriptor::FileDescriptorProto> {
        ::std::mem::replace(&mut self.proto_file, ::protobuf::RepeatedField::new())
    }

    // optional .google.protobuf.compiler.Version compiler_version = 3;


    pub fn get_compiler_version(&self) -> &Version {
        self.compiler_version.as_ref().unwrap_or_else(|| Version::default_instance())
    }
    pub fn clear_compiler_version(&mut self) {
        self.compiler_version.clear();
    }

    pub fn has_compiler_version(&self) -> bool {
        self.compiler_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compiler_version(&mut self, v: Version) {
        self.compiler_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compiler_version(&mut self) -> &mut Version {
        if self.compiler_version.is_none() {
            self.compiler_version.set_default();
        }
        self.compiler_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_compiler_version(&mut self) -> Version {
        self.compiler_version.take().unwrap_or_else(|| Version::new())
    }
}

impl ::protobuf::Message for CodeGeneratorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.proto_file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.compiler_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.file_to_generate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.parameter)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.proto_file)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.compiler_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.file_to_generate {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.parameter.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.proto_file {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.compiler_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.file_to_generate {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.parameter.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.proto_file {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.compiler_version.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodeGeneratorRequest {
        CodeGeneratorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_to_generate",
                    |m: &CodeGeneratorRequest| { &m.file_to_generate },
                    |m: &mut CodeGeneratorRequest| { &mut m.file_to_generate },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parameter",
                    |m: &CodeGeneratorRequest| { &m.parameter },
                    |m: &mut CodeGeneratorRequest| { &mut m.parameter },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::descriptor::FileDescriptorProto>>(
                    "proto_file",
                    |m: &CodeGeneratorRequest| { &m.proto_file },
                    |m: &mut CodeGeneratorRequest| { &mut m.proto_file },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Version>>(
                    "compiler_version",
                    |m: &CodeGeneratorRequest| { &m.compiler_version },
                    |m: &mut CodeGeneratorRequest| { &mut m.compiler_version },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CodeGeneratorRequest>(
                    "CodeGeneratorRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CodeGeneratorRequest {
        static mut instance: ::protobuf::lazy::Lazy<CodeGeneratorRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CodeGeneratorRequest::new)
        }
    }
}

impl ::protobuf::Clear for CodeGeneratorRequest {
    fn clear(&mut self) {
        self.file_to_generate.clear();
        self.parameter.clear();
        self.proto_file.clear();
        self.compiler_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodeGeneratorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeGeneratorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodeGeneratorResponse {
    // message fields
    error: ::protobuf::SingularField<::std::string::String>,
    supported_features: ::std::option::Option<u64>,
    file: ::protobuf::RepeatedField<CodeGeneratorResponse_File>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CodeGeneratorResponse {
    fn default() -> &'a CodeGeneratorResponse {
        <CodeGeneratorResponse as ::protobuf::Message>::default_instance()
    }
}

impl CodeGeneratorResponse {
    pub fn new() -> CodeGeneratorResponse {
        ::std::default::Default::default()
    }

    // optional string error = 1;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 supported_features = 2;


    pub fn get_supported_features(&self) -> u64 {
        self.supported_features.unwrap_or(0)
    }
    pub fn clear_supported_features(&mut self) {
        self.supported_features = ::std::option::Option::None;
    }

    pub fn has_supported_features(&self) -> bool {
        self.supported_features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supported_features(&mut self, v: u64) {
        self.supported_features = ::std::option::Option::Some(v);
    }

    // repeated .google.protobuf.compiler.CodeGeneratorResponse.File file = 15;


    pub fn get_file(&self) -> &[CodeGeneratorResponse_File] {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::protobuf::RepeatedField<CodeGeneratorResponse_File>) {
        self.file = v;
    }

    // Mutable pointer to the field.
    pub fn mut_file(&mut self) -> &mut ::protobuf::RepeatedField<CodeGeneratorResponse_File> {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::protobuf::RepeatedField<CodeGeneratorResponse_File> {
        ::std::mem::replace(&mut self.file, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CodeGeneratorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.supported_features = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.file)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.supported_features {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.supported_features {
            os.write_uint64(2, v)?;
        }
        for v in &self.file {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodeGeneratorResponse {
        CodeGeneratorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "error",
                    |m: &CodeGeneratorResponse| { &m.error },
                    |m: &mut CodeGeneratorResponse| { &mut m.error },
                ));
                fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "supported_features",
                    |m: &CodeGeneratorResponse| { &m.supported_features },
                    |m: &mut CodeGeneratorResponse| { &mut m.supported_features },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeGeneratorResponse_File>>(
                    "file",
                    |m: &CodeGeneratorResponse| { &m.file },
                    |m: &mut CodeGeneratorResponse| { &mut m.file },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CodeGeneratorResponse>(
                    "CodeGeneratorResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CodeGeneratorResponse {
        static mut instance: ::protobuf::lazy::Lazy<CodeGeneratorResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CodeGeneratorResponse::new)
        }
    }
}

impl ::protobuf::Clear for CodeGeneratorResponse {
    fn clear(&mut self) {
        self.error.clear();
        self.supported_features = ::std::option::Option::None;
        self.file.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodeGeneratorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeGeneratorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodeGeneratorResponse_File {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    insertion_point: ::protobuf::SingularField<::std::string::String>,
    content: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CodeGeneratorResponse_File {
    fn default() -> &'a CodeGeneratorResponse_File {
        <CodeGeneratorResponse_File as ::protobuf::Message>::default_instance()
    }
}

impl CodeGeneratorResponse_File {
    pub fn new() -> CodeGeneratorResponse_File {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string insertion_point = 2;


    pub fn get_insertion_point(&self) -> &str {
        match self.insertion_point.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_insertion_point(&mut self) {
        self.insertion_point.clear();
    }

    pub fn has_insertion_point(&self) -> bool {
        self.insertion_point.is_some()
    }

    // Param is passed by value, moved
    pub fn set_insertion_point(&mut self, v: ::std::string::String) {
        self.insertion_point = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_insertion_point(&mut self) -> &mut ::std::string::String {
        if self.insertion_point.is_none() {
            self.insertion_point.set_default();
        }
        self.insertion_point.as_mut().unwrap()
    }

    // Take field
    pub fn take_insertion_point(&mut self) -> ::std::string::String {
        self.insertion_point.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string content = 15;


    pub fn get_content(&self) -> &str {
        match self.content.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::string::String) {
        self.content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::string::String {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::string::String {
        self.content.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CodeGeneratorResponse_File {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.insertion_point)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.insertion_point.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.content.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.insertion_point.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_string(15, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodeGeneratorResponse_File {
        CodeGeneratorResponse_File::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &CodeGeneratorResponse_File| { &m.name },
                    |m: &mut CodeGeneratorResponse_File| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "insertion_point",
                    |m: &CodeGeneratorResponse_File| { &m.insertion_point },
                    |m: &mut CodeGeneratorResponse_File| { &mut m.insertion_point },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "content",
                    |m: &CodeGeneratorResponse_File| { &m.content },
                    |m: &mut CodeGeneratorResponse_File| { &mut m.content },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CodeGeneratorResponse_File>(
                    "CodeGeneratorResponse.File",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CodeGeneratorResponse_File {
        static mut instance: ::protobuf::lazy::Lazy<CodeGeneratorResponse_File> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CodeGeneratorResponse_File::new)
        }
    }
}

impl ::protobuf::Clear for CodeGeneratorResponse_File {
    fn clear(&mut self) {
        self.name.clear();
        self.insertion_point.clear();
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodeGeneratorResponse_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeGeneratorResponse_File {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CodeGeneratorResponse_Feature {
    FEATURE_NONE = 0,
    FEATURE_PROTO3_OPTIONAL = 1,
}

impl ::protobuf::ProtobufEnum for CodeGeneratorResponse_Feature {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CodeGeneratorResponse_Feature> {
        match value {
            0 => ::std::option::Option::Some(CodeGeneratorResponse_Feature::FEATURE_NONE),
            1 => ::std::option::Option::Some(CodeGeneratorResponse_Feature::FEATURE_PROTO3_OPTIONAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CodeGeneratorResponse_Feature] = &[
            CodeGeneratorResponse_Feature::FEATURE_NONE,
            CodeGeneratorResponse_Feature::FEATURE_PROTO3_OPTIONAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<CodeGeneratorResponse_Feature>("CodeGeneratorResponse.Feature", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CodeGeneratorResponse_Feature {
}

impl ::std::default::Default for CodeGeneratorResponse_Feature {
    fn default() -> Self {
        CodeGeneratorResponse_Feature::FEATURE_NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeGeneratorResponse_Feature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12proto/plugin.proto\x12\x18google.protobuf.compiler\x1a\x20google/p\
    rotobuf/descriptor.proto\"c\n\x07Version\x12\x14\n\x05major\x18\x01\x20\
    \x01(\x05R\x05major\x12\x14\n\x05minor\x18\x02\x20\x01(\x05R\x05minor\
    \x12\x14\n\x05patch\x18\x03\x20\x01(\x05R\x05patch\x12\x16\n\x06suffix\
    \x18\x04\x20\x01(\tR\x06suffix\"\xf1\x01\n\x14CodeGeneratorRequest\x12(\
    \n\x10file_to_generate\x18\x01\x20\x03(\tR\x0efileToGenerate\x12\x1c\n\t\
    parameter\x18\x02\x20\x01(\tR\tparameter\x12C\n\nproto_file\x18\x0f\x20\
    \x03(\x0b2$.google.protobuf.FileDescriptorProtoR\tprotoFile\x12L\n\x10co\
    mpiler_version\x18\x03\x20\x01(\x0b2!.google.protobuf.compiler.VersionR\
    \x0fcompilerVersion\"\xbf\x02\n\x15CodeGeneratorResponse\x12\x14\n\x05er\
    ror\x18\x01\x20\x01(\tR\x05error\x12-\n\x12supported_features\x18\x02\
    \x20\x01(\x04R\x11supportedFeatures\x12H\n\x04file\x18\x0f\x20\x03(\x0b2\
    4.google.protobuf.compiler.CodeGeneratorResponse.FileR\x04file\x1a]\n\
    \x04File\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12'\n\x0finserti\
    on_point\x18\x02\x20\x01(\tR\x0einsertionPoint\x12\x18\n\x07content\x18\
    \x0f\x20\x01(\tR\x07content\"8\n\x07Feature\x12\x10\n\x0cFEATURE_NONE\
    \x10\0\x12\x1b\n\x17FEATURE_PROTO3_OPTIONAL\x10\x01Bg\n\x1ccom.google.pr\
    otobuf.compilerB\x0cPluginProtosZ9github.com/golang/protobuf/protoc-gen-\
    go/plugin;plugin_goJ\xd1A\n\x07\x12\x05.\0\xb1\x01\x01\n\xca\x11\n\x01\
    \x0c\x12\x03.\0\x122\xc1\x0c\x20Protocol\x20Buffers\x20-\x20Google's\x20\
    data\x20interchange\x20format\n\x20Copyright\x202008\x20Google\x20Inc.\
    \x20\x20All\x20rights\x20reserved.\n\x20https://developers.google.com/pr\
    otocol-buffers/\n\n\x20Redistribution\x20and\x20use\x20in\x20source\x20a\
    nd\x20binary\x20forms,\x20with\x20or\x20without\n\x20modification,\x20ar\
    e\x20permitted\x20provided\x20that\x20the\x20following\x20conditions\x20\
    are\n\x20met:\n\n\x20\x20\x20\x20\x20*\x20Redistributions\x20of\x20sourc\
    e\x20code\x20must\x20retain\x20the\x20above\x20copyright\n\x20notice,\
    \x20this\x20list\x20of\x20conditions\x20and\x20the\x20following\x20discl\
    aimer.\n\x20\x20\x20\x20\x20*\x20Redistributions\x20in\x20binary\x20form\
    \x20must\x20reproduce\x20the\x20above\n\x20copyright\x20notice,\x20this\
    \x20list\x20of\x20conditions\x20and\x20the\x20following\x20disclaimer\n\
    \x20in\x20the\x20documentation\x20and/or\x20other\x20materials\x20provid\
    ed\x20with\x20the\n\x20distribution.\n\x20\x20\x20\x20\x20*\x20Neither\
    \x20the\x20name\x20of\x20Google\x20Inc.\x20nor\x20the\x20names\x20of\x20\
    its\n\x20contributors\x20may\x20be\x20used\x20to\x20endorse\x20or\x20pro\
    mote\x20products\x20derived\x20from\n\x20this\x20software\x20without\x20\
    specific\x20prior\x20written\x20permission.\n\n\x20THIS\x20SOFTWARE\x20I\
    S\x20PROVIDED\x20BY\x20THE\x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTOR\
    S\n\x20\"AS\x20IS\"\x20AND\x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANT\
    IES,\x20INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\
    \x20WARRANTIES\x20OF\x20MERCHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\
    \x20PARTICULAR\x20PURPOSE\x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20\
    SHALL\x20THE\x20COPYRIGHT\n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIAB\
    LE\x20FOR\x20ANY\x20DIRECT,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\
    \x20EXEMPLARY,\x20OR\x20CONSEQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\
    \x20NOT\n\x20LIMITED\x20TO,\x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\
    \x20OR\x20SERVICES;\x20LOSS\x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\
    \x20OR\x20BUSINESS\x20INTERRUPTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\
    \x20ANY\n\x20THEORY\x20OF\x20LIABILITY,\x20WHETHER\x20IN\x20CONTRACT,\
    \x20STRICT\x20LIABILITY,\x20OR\x20TORT\n\x20(INCLUDING\x20NEGLIGENCE\x20\
    OR\x20OTHERWISE)\x20ARISING\x20IN\x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20U\
    SE\n\x20OF\x20THIS\x20SOFTWARE,\x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\
    \x20POSSIBILITY\x20OF\x20SUCH\x20DAMAGE.\n2\xfb\x04\x20Author:\x20kenton\
    @google.com\x20(Kenton\x20Varda)\n\n\x20WARNING:\x20\x20The\x20plugin\
    \x20interface\x20is\x20currently\x20EXPERIMENTAL\x20and\x20is\x20subject\
    \x20to\n\x20\x20\x20change.\n\n\x20protoc\x20(aka\x20the\x20Protocol\x20\
    Compiler)\x20can\x20be\x20extended\x20via\x20plugins.\x20\x20A\x20plugin\
    \x20is\n\x20just\x20a\x20program\x20that\x20reads\x20a\x20CodeGeneratorR\
    equest\x20from\x20stdin\x20and\x20writes\x20a\n\x20CodeGeneratorResponse\
    \x20to\x20stdout.\n\n\x20Plugins\x20written\x20using\x20C++\x20can\x20us\
    e\x20google/protobuf/compiler/plugin.h\x20instead\n\x20of\x20dealing\x20\
    with\x20the\x20raw\x20protocol\x20defined\x20here.\n\n\x20A\x20plugin\
    \x20executable\x20needs\x20only\x20to\x20be\x20placed\x20somewhere\x20in\
    \x20the\x20path.\x20\x20The\n\x20plugin\x20should\x20be\x20named\x20\"pr\
    otoc-gen-$NAME\",\x20and\x20will\x20then\x20be\x20used\x20when\x20the\n\
    \x20flag\x20\"--${NAME}_out\"\x20is\x20passed\x20to\x20protoc.\n\n\x08\n\
    \x01\x02\x12\x030\0!\n\x08\n\x01\x08\x12\x031\05\n\t\n\x02\x08\x01\x12\
    \x031\05\n\x08\n\x01\x08\x12\x032\0-\n\t\n\x02\x08\x08\x12\x032\0-\n\x08\
    \n\x01\x08\x12\x034\0P\n\t\n\x02\x08\x0b\x12\x034\0P\n\t\n\x02\x03\0\x12\
    \x036\0*\n6\n\x02\x04\0\x12\x049\0@\x01\x1a*\x20The\x20version\x20number\
    \x20of\x20protocol\x20compiler.\n\n\n\n\x03\x04\0\x01\x12\x039\x08\x0f\n\
    \x0b\n\x04\x04\0\x02\0\x12\x03:\x02\x1b\n\x0c\n\x05\x04\0\x02\0\x04\x12\
    \x03:\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03:\x0b\x10\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03:\x11\x16\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03:\x19\
    \x1a\n\x0b\n\x04\x04\0\x02\x01\x12\x03;\x02\x1b\n\x0c\n\x05\x04\0\x02\
    \x01\x04\x12\x03;\x02\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03;\x0b\x10\n\
    \x0c\n\x05\x04\0\x02\x01\x01\x12\x03;\x11\x16\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x03;\x19\x1a\n\x0b\n\x04\x04\0\x02\x02\x12\x03<\x02\x1b\n\x0c\n\
    \x05\x04\0\x02\x02\x04\x12\x03<\x02\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\
    \x03<\x0b\x10\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03<\x11\x16\n\x0c\n\x05\
    \x04\0\x02\x02\x03\x12\x03<\x19\x1a\n\x80\x01\n\x04\x04\0\x02\x03\x12\
    \x03?\x02\x1d\x1as\x20A\x20suffix\x20for\x20alpha,\x20beta\x20or\x20rc\
    \x20release,\x20e.g.,\x20\"alpha-1\",\x20\"rc2\".\x20It\x20should\n\x20b\
    e\x20empty\x20for\x20mainline\x20stable\x20releases.\n\n\x0c\n\x05\x04\0\
    \x02\x03\x04\x12\x03?\x02\n\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03?\x0b\
    \x11\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03?\x12\x18\n\x0c\n\x05\x04\0\
    \x02\x03\x03\x12\x03?\x1b\x1c\nO\n\x02\x04\x01\x12\x04C\0_\x01\x1aC\x20A\
    n\x20encoded\x20CodeGeneratorRequest\x20is\x20written\x20to\x20the\x20pl\
    ugin's\x20stdin.\n\n\n\n\x03\x04\x01\x01\x12\x03C\x08\x1c\n\xd1\x01\n\
    \x04\x04\x01\x02\0\x12\x03G\x02'\x1a\xc3\x01\x20The\x20.proto\x20files\
    \x20that\x20were\x20explicitly\x20listed\x20on\x20the\x20command-line.\
    \x20\x20The\n\x20code\x20generator\x20should\x20generate\x20code\x20only\
    \x20for\x20these\x20files.\x20\x20Each\x20file's\n\x20descriptor\x20will\
    \x20be\x20included\x20in\x20proto_file,\x20below.\n\n\x0c\n\x05\x04\x01\
    \x02\0\x04\x12\x03G\x02\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03G\x0b\x11\
    \n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03G\x12\"\n\x0c\n\x05\x04\x01\x02\0\
    \x03\x12\x03G%&\nB\n\x04\x04\x01\x02\x01\x12\x03J\x02\x20\x1a5\x20The\
    \x20generator\x20parameter\x20passed\x20on\x20the\x20command-line.\n\n\
    \x0c\n\x05\x04\x01\x02\x01\x04\x12\x03J\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x01\x05\x12\x03J\x0b\x11\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03J\x12\
    \x1b\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03J\x1e\x1f\n\x87\x06\n\x04\
    \x04\x01\x02\x02\x12\x03Z\x02/\x1a\xf9\x05\x20FileDescriptorProtos\x20fo\
    r\x20all\x20files\x20in\x20files_to_generate\x20and\x20everything\n\x20t\
    hey\x20import.\x20\x20The\x20files\x20will\x20appear\x20in\x20topologica\
    l\x20order,\x20so\x20each\x20file\n\x20appears\x20before\x20any\x20file\
    \x20that\x20imports\x20it.\n\n\x20protoc\x20guarantees\x20that\x20all\
    \x20proto_files\x20will\x20be\x20written\x20after\n\x20the\x20fields\x20\
    above,\x20even\x20though\x20this\x20is\x20not\x20technically\x20guarante\
    ed\x20by\x20the\n\x20protobuf\x20wire\x20format.\x20\x20This\x20theoreti\
    cally\x20could\x20allow\x20a\x20plugin\x20to\x20stream\n\x20in\x20the\
    \x20FileDescriptorProtos\x20and\x20handle\x20them\x20one\x20by\x20one\
    \x20rather\x20than\x20read\n\x20the\x20entire\x20set\x20into\x20memory\
    \x20at\x20once.\x20\x20However,\x20as\x20of\x20this\x20writing,\x20this\
    \n\x20is\x20not\x20similarly\x20optimized\x20on\x20protoc's\x20end\x20--\
    \x20it\x20will\x20store\x20all\x20fields\x20in\n\x20memory\x20at\x20once\
    \x20before\x20sending\x20them\x20to\x20the\x20plugin.\n\n\x20Type\x20nam\
    es\x20of\x20fields\x20and\x20extensions\x20in\x20the\x20FileDescriptorPr\
    oto\x20are\x20always\n\x20fully\x20qualified.\n\n\x0c\n\x05\x04\x01\x02\
    \x02\x04\x12\x03Z\x02\n\n\x0c\n\x05\x04\x01\x02\x02\x06\x12\x03Z\x0b\x1e\
    \n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03Z\x1f)\n\x0c\n\x05\x04\x01\x02\
    \x02\x03\x12\x03Z,.\n7\n\x04\x04\x01\x02\x03\x12\x03]\x02(\x1a*\x20The\
    \x20version\x20number\x20of\x20protocol\x20compiler.\n\n\x0c\n\x05\x04\
    \x01\x02\x03\x04\x12\x03]\x02\n\n\x0c\n\x05\x04\x01\x02\x03\x06\x12\x03]\
    \x0b\x12\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03]\x13#\n\x0c\n\x05\x04\
    \x01\x02\x03\x03\x12\x03]&'\nL\n\x02\x04\x02\x12\x05b\0\xb1\x01\x01\x1a?\
    \x20The\x20plugin\x20writes\x20an\x20encoded\x20CodeGeneratorResponse\
    \x20to\x20stdout.\n\n\n\n\x03\x04\x02\x01\x12\x03b\x08\x1d\n\xed\x03\n\
    \x04\x04\x02\x02\0\x12\x03k\x02\x1c\x1a\xdf\x03\x20Error\x20message.\x20\
    \x20If\x20non-empty,\x20code\x20generation\x20failed.\x20\x20The\x20plug\
    in\x20process\n\x20should\x20exit\x20with\x20status\x20code\x20zero\x20e\
    ven\x20if\x20it\x20reports\x20an\x20error\x20in\x20this\x20way.\n\n\x20T\
    his\x20should\x20be\x20used\x20to\x20indicate\x20errors\x20in\x20.proto\
    \x20files\x20which\x20prevent\x20the\n\x20code\x20generator\x20from\x20g\
    enerating\x20correct\x20code.\x20\x20Errors\x20which\x20indicate\x20a\n\
    \x20problem\x20in\x20protoc\x20itself\x20--\x20such\x20as\x20the\x20inpu\
    t\x20CodeGeneratorRequest\x20being\n\x20unparseable\x20--\x20should\x20b\
    e\x20reported\x20by\x20writing\x20a\x20message\x20to\x20stderr\x20and\n\
    \x20exiting\x20with\x20a\x20non-zero\x20status\x20code.\n\n\x0c\n\x05\
    \x04\x02\x02\0\x04\x12\x03k\x02\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03k\
    \x0b\x11\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03k\x12\x17\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03k\x1a\x1b\n\x89\x01\n\x04\x04\x02\x02\x01\x12\x03o\
    \x02)\x1a|\x20A\x20bitmask\x20of\x20supported\x20features\x20that\x20the\
    \x20code\x20generator\x20supports.\n\x20This\x20is\x20a\x20bitwise\x20\"\
    or\"\x20of\x20values\x20from\x20the\x20Feature\x20enum.\n\n\x0c\n\x05\
    \x04\x02\x02\x01\x04\x12\x03o\x02\n\n\x0c\n\x05\x04\x02\x02\x01\x05\x12\
    \x03o\x0b\x11\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03o\x12$\n\x0c\n\x05\
    \x04\x02\x02\x01\x03\x12\x03o'(\n+\n\x04\x04\x02\x04\0\x12\x04r\x02u\x03\
    \x1a\x1d\x20Sync\x20with\x20code_generator.h.\n\n\x0c\n\x05\x04\x02\x04\
    \0\x01\x12\x03r\x07\x0e\n\r\n\x06\x04\x02\x04\0\x02\0\x12\x03s\x04\x15\n\
    \x0e\n\x07\x04\x02\x04\0\x02\0\x01\x12\x03s\x04\x10\n\x0e\n\x07\x04\x02\
    \x04\0\x02\0\x02\x12\x03s\x13\x14\n\r\n\x06\x04\x02\x04\0\x02\x01\x12\
    \x03t\x04\x20\n\x0e\n\x07\x04\x02\x04\0\x02\x01\x01\x12\x03t\x04\x1b\n\
    \x0e\n\x07\x04\x02\x04\0\x02\x01\x02\x12\x03t\x1e\x1f\n4\n\x04\x04\x02\
    \x03\0\x12\x05x\x02\xaf\x01\x03\x1a%\x20Represents\x20a\x20single\x20gen\
    erated\x20file.\n\n\x0c\n\x05\x04\x02\x03\0\x01\x12\x03x\n\x0e\n\xae\x05\
    \n\x06\x04\x02\x03\0\x02\0\x12\x04\x84\x01\x04\x1d\x1a\x9d\x05\x20The\
    \x20file\x20name,\x20relative\x20to\x20the\x20output\x20directory.\x20\
    \x20The\x20name\x20must\x20not\n\x20contain\x20\".\"\x20or\x20\"..\"\x20\
    components\x20and\x20must\x20be\x20relative,\x20not\x20be\x20absolute\
    \x20(so,\n\x20the\x20file\x20cannot\x20lie\x20outside\x20the\x20output\
    \x20directory).\x20\x20\"/\"\x20must\x20be\x20used\x20as\n\x20the\x20pat\
    h\x20separator,\x20not\x20\"\\\".\n\n\x20If\x20the\x20name\x20is\x20omit\
    ted,\x20the\x20content\x20will\x20be\x20appended\x20to\x20the\x20previou\
    s\n\x20file.\x20\x20This\x20allows\x20the\x20generator\x20to\x20break\
    \x20large\x20files\x20into\x20small\x20chunks,\n\x20and\x20allows\x20the\
    \x20generated\x20text\x20to\x20be\x20streamed\x20back\x20to\x20protoc\
    \x20so\x20that\x20large\n\x20files\x20need\x20not\x20reside\x20completel\
    y\x20in\x20memory\x20at\x20one\x20time.\x20\x20Note\x20that\x20as\x20of\
    \n\x20this\x20writing\x20protoc\x20does\x20not\x20optimize\x20for\x20thi\
    s\x20--\x20it\x20will\x20read\x20the\x20entire\n\x20CodeGeneratorRespons\
    e\x20before\x20writing\x20files\x20to\x20disk.\n\n\x0f\n\x07\x04\x02\x03\
    \0\x02\0\x04\x12\x04\x84\x01\x04\x0c\n\x0f\n\x07\x04\x02\x03\0\x02\0\x05\
    \x12\x04\x84\x01\r\x13\n\x0f\n\x07\x04\x02\x03\0\x02\0\x01\x12\x04\x84\
    \x01\x14\x18\n\x0f\n\x07\x04\x02\x03\0\x02\0\x03\x12\x04\x84\x01\x1b\x1c\
    \n\xae\x10\n\x06\x04\x02\x03\0\x02\x01\x12\x04\xab\x01\x04(\x1a\x9d\x10\
    \x20If\x20non-empty,\x20indicates\x20that\x20the\x20named\x20file\x20sho\
    uld\x20already\x20exist,\x20and\x20the\n\x20content\x20here\x20is\x20to\
    \x20be\x20inserted\x20into\x20that\x20file\x20at\x20a\x20defined\x20inse\
    rtion\n\x20point.\x20\x20This\x20feature\x20allows\x20a\x20code\x20gener\
    ator\x20to\x20extend\x20the\x20output\n\x20produced\x20by\x20another\x20\
    code\x20generator.\x20\x20The\x20original\x20generator\x20may\x20provide\
    \n\x20insertion\x20points\x20by\x20placing\x20special\x20annotations\x20\
    in\x20the\x20file\x20that\x20look\n\x20like:\n\x20\x20\x20@@protoc_inser\
    tion_point(NAME)\n\x20The\x20annotation\x20can\x20have\x20arbitrary\x20t\
    ext\x20before\x20and\x20after\x20it\x20on\x20the\x20line,\n\x20which\x20\
    allows\x20it\x20to\x20be\x20placed\x20in\x20a\x20comment.\x20\x20NAME\
    \x20should\x20be\x20replaced\x20with\n\x20an\x20identifier\x20naming\x20\
    the\x20point\x20--\x20this\x20is\x20what\x20other\x20generators\x20will\
    \x20use\n\x20as\x20the\x20insertion_point.\x20\x20Code\x20inserted\x20at\
    \x20this\x20point\x20will\x20be\x20placed\n\x20immediately\x20above\x20t\
    he\x20line\x20containing\x20the\x20insertion\x20point\x20(thus\x20multip\
    le\n\x20insertions\x20to\x20the\x20same\x20point\x20will\x20come\x20out\
    \x20in\x20the\x20order\x20they\x20were\x20added).\n\x20The\x20double-@\
    \x20is\x20intended\x20to\x20make\x20it\x20unlikely\x20that\x20the\x20gen\
    erated\x20code\n\x20could\x20contain\x20things\x20that\x20look\x20like\
    \x20insertion\x20points\x20by\x20accident.\n\n\x20For\x20example,\x20the\
    \x20C++\x20code\x20generator\x20places\x20the\x20following\x20line\x20in\
    \x20the\n\x20.pb.h\x20files\x20that\x20it\x20generates:\n\x20\x20\x20//\
    \x20@@protoc_insertion_point(namespace_scope)\n\x20This\x20line\x20appea\
    rs\x20within\x20the\x20scope\x20of\x20the\x20file's\x20package\x20namesp\
    ace,\x20but\n\x20outside\x20of\x20any\x20particular\x20class.\x20\x20Ano\
    ther\x20plugin\x20can\x20then\x20specify\x20the\n\x20insertion_point\x20\
    \"namespace_scope\"\x20to\x20generate\x20additional\x20classes\x20or\n\
    \x20other\x20declarations\x20that\x20should\x20be\x20placed\x20in\x20thi\
    s\x20scope.\n\n\x20Note\x20that\x20if\x20the\x20line\x20containing\x20th\
    e\x20insertion\x20point\x20begins\x20with\n\x20whitespace,\x20the\x20sam\
    e\x20whitespace\x20will\x20be\x20added\x20to\x20every\x20line\x20of\x20t\
    he\n\x20inserted\x20text.\x20\x20This\x20is\x20useful\x20for\x20language\
    s\x20like\x20Python,\x20where\n\x20indentation\x20matters.\x20\x20In\x20\
    these\x20languages,\x20the\x20insertion\x20point\x20comment\n\x20should\
    \x20be\x20indented\x20the\x20same\x20amount\x20as\x20any\x20inserted\x20\
    code\x20will\x20need\x20to\x20be\n\x20in\x20order\x20to\x20work\x20corre\
    ctly\x20in\x20that\x20context.\n\n\x20The\x20code\x20generator\x20that\
    \x20generates\x20the\x20initial\x20file\x20and\x20the\x20one\x20which\n\
    \x20inserts\x20into\x20it\x20must\x20both\x20run\x20as\x20part\x20of\x20\
    a\x20single\x20invocation\x20of\x20protoc.\n\x20Code\x20generators\x20ar\
    e\x20executed\x20in\x20the\x20order\x20in\x20which\x20they\x20appear\x20\
    on\x20the\n\x20command\x20line.\n\n\x20If\x20|insertion_point|\x20is\x20\
    present,\x20|name|\x20must\x20also\x20be\x20present.\n\n\x0f\n\x07\x04\
    \x02\x03\0\x02\x01\x04\x12\x04\xab\x01\x04\x0c\n\x0f\n\x07\x04\x02\x03\0\
    \x02\x01\x05\x12\x04\xab\x01\r\x13\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x01\
    \x12\x04\xab\x01\x14#\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x03\x12\x04\xab\
    \x01&'\n$\n\x06\x04\x02\x03\0\x02\x02\x12\x04\xae\x01\x04!\x1a\x14\x20Th\
    e\x20file\x20contents.\n\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x04\
    \xae\x01\x04\x0c\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x05\x12\x04\xae\x01\r\
    \x13\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x01\x12\x04\xae\x01\x14\x1b\n\x0f\
    \n\x07\x04\x02\x03\0\x02\x02\x03\x12\x04\xae\x01\x1e\x20\n\x0c\n\x04\x04\
    \x02\x02\x02\x12\x04\xb0\x01\x02\x1a\n\r\n\x05\x04\x02\x02\x02\x04\x12\
    \x04\xb0\x01\x02\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\xb0\x01\x0b\x0f\
    \n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xb0\x01\x10\x14\n\r\n\x05\x04\x02\
    \x02\x02\x03\x12\x04\xb0\x01\x17\x19\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
